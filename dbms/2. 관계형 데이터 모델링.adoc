= 2. 관계형 데이터 모델링
include::../_toc.adoc[]

== 2.1. 데이터-모델링
=== 데이터 모델링 3요소
데이터구조(Data Structure):: 개체와 개체 간 관계를 명세 (Schema)
연산(Operations):: 개체를 처리하는 작업에 대한 명세
제약조건(Constraint):: DB 에 허용될 수 있는 개체에 대한 논리적 제약 명세

== 2.2. DB-생명주기와-설계단계
=== 2.2.1. 요구분석
* 요구 분석
* 정보의 내용과 처리 요구조건의 수집
* 기업의 경영목표와 제약조건의 식별
* 공식적인 요구조건 명세 작성
* 요구조건 명세표 검토

=== 2.2.2. 개념 설계
*핵심 엔티티 도출*

==== 개념적 스키마 모델링
개체분석(Entity Analysis:EA) 방법:: 하향식
속성합성(Attribute Synthesis:AS) 방법:: 상향식

==== 트랜잭션 모델링
* 트랜잭션 식별
* 트랜잭션 중요도
* 트랜잭션 _예상 빈도_

=== 2.2.3. 논리 설계
==== ERT 표기법
1. IE
2. Baker
3. Chen
4. min/Max

=== 2.2.4. 물리 설계
_정규화_


== 2.3. ERD-와-E-ERD
==== E-R 모델과 관계형 모델의 변화
[cols="^2,^2,<4,<2"]
|===
| Diagram   | 개념 모델     ^| 논리 모델                ^| 물리 모델

|           | Entity        a| Relation                 a| Table
|           | Attribute     a| * Attribute
* Relation
a| * Column
* table
|           | Relationship  a| * 소멸
* Relation
** 관계속성이 있는 경우
** N:M 관계일 때
** 3진 차수
a| * _FK_
* Table
|           | 없음          a| Tuple                     a| Record(Row)
|           | 식별자        a| 식별자                    a| Key
|===

=== 2.3.1. ER Model
==== 1) ER Model Diagram 표기법
[cols="^1,<2"]
|===
|           | 엔티티
|           | 약한 엔티티
|           | 관계 (Relationship)
|           | 식별 관계
|           | 속성(Attribute)
|           | 키 속성(Attribute)
|           | 약한 키 속성(Attribute)
|           | *다치 속성(Attribute)* (여러 값을 가질 수 있음. eg> 취미)
|           | 복합 속성(Attribute) (세부 속성으로 분해 가능. eg> 주소)
|           | 유도된 속성(Attribute) (eg> 합계, 평균)
|           | 부분 참여 / 전체참여
|           | 카디날리티
|           | 참조(참여) 제약조건
|===

==== 2) 개체(Entity)
==== 3) 속성(Attribute)
==== 4) 관계(Relationship)
차수(Degree):: 관계에 참여하는 개체의 수
* 이진(Binary)차수 : 관계에 참여하는 개체가 2개
* 삼진(Ternary)차수 : 관계에 참여하는 개체가  3개
* 단일(Unary)차수 : 관계에 참여하는 개체가  1개 (Recurve)
기수성(Cardinality):: 개체가 참여할 수 있는 관계의 수
* 1:1
* 1:N
* N:M
선택성(Optionality):: 특정 개체와 관련된 상대 개체의 존재 여부
* Mandatory
* Optional

==== 5) 개체 타입
약한 개체 타입:: 자신의 속성만으로 키를 명세할 수 없는 개체
강한 개체 타입:: 자신의 속성으로 구성된 키를 가진 개체
식별관게:: 약한 개체를 강한 개체와 연관 시켜주는 관계
* eg> 대출이 없으면 상환도 없다

=== 2.3.2. 확장형 E-R 모델
* 특수화
* 일반화
* 상속
* 집단화
* Disjoint Constrain
* Non-disjoint Constrain

== 2.4. 관계형-모델
=== 2.4.1. 속성(Attribute)와 도메인
* Domain
* Attribute

=== 2.4.2 Relation (Table)
* TODO: Relation Image

==== Relation 의 특징 (집합개념)
튜플의 유일성:: 한 Relation 에 속한 모든 Tuple 은 유일하다
튜플의 무 순서성:: Tuple 의 순서가 없다
속성의 무 순서성:: 한 Relation 을 구성하는 속성(Attribute) 의 순서가 없다
속성의 원자성:: 속성(Attribute) 은 더 이상 분해할 수 없다

=== 2.4.3. 키(Key)
후보키(Candidate Key):: #유일성과 최소성을 만족#
* _유일성_ : 키의 값으로 Relation 의 Tuple 구분 (Unique and Not Null)
* _최소성_ : 유일성을 지니는 최소한의 속성만을 포함
기본키(Primary Key):: 후보키가 둘 이상인 경우 대표키로 선정된 키
대체키(Alternate Key):: 후보키 중 기본키가 아닌 키
슈퍼키(Super Key):: 유일성을 만족하나, 최소성을 만족하지 않는 키
* 각 행을 유일하게 식별할 수 있는 ##하나 또는 그 이상의 속성들의 집합##이다.
* eg> 주민번호 + 이름
외래키(Foreign Key):: 다른 엔티티의 Tuple 을 식별할 수 있는 키

=== 2.4.4. 무결성 제약
데이터 무결성::
데이터베이스 상태::
널(NULL)::
키(Key)를 기본으로 하는 무결성 제약::
* 개체 무결성
* 참조 무결성

== 2.5. 관계 대수
=== 2.5.1. 관계 대수 vs 관계 해석
=== 2.5.2. 관계 대수 (집합 연산)
[cols="3,^1,<4"]
.기본연산/근원연산
|===
| 선택 Select (&sigma;)           | &sigma;   | &sigma;~condition~\(R)
| 추출 Project (&Pi;)             | &Pi;      | &Pi;~A1,A2..Ak~\(R)
| 합집합 Union (&cup;)            | &cup;     | R &cup; S
| 차집합 Difference (-)           | -         | R - S
| 카티션 곱 Cartesian Product (x) | x         | R x S
| 재명명 Rename (&rho;)           | &rho;     | &rho;~x~(E)
|===

[cols="3,^1,<4"]
.부가연산/복합연산
|===
| 교집합 Intersection (&cap;)      | &cap;    | R &cap; S
| 나누기 Division (&div;)          | &div;    | R &div; S
| 동등조인/자연조인 (⋈)            | ⋈      | R ⋈ S
| 세타조인 (⋈θ)                    | ⋈θ     | R ⋈θ S
| 자연조인 (⋈N)                    | ⋈N     | R ⋈N S
| 세미조인 (⋉)                     | ⋉      | R ⋉ S
| 외부조인 Left (⟕)                | ⟕      | R ⟕ S
| 외부조인 Right (⟖)               | ⟖      | R ⟖ S
| 외부조인 Full (⟗)                | ⟗      | R ⟗ S
| 배정 Assignment (&larr;)          | &larr;  | temp1 &larr; &Pi;~R-S~\(A)
|===

=== 2.5.2-1. 연산의 종류: #일반학생 _학교카차_, *복합생* _조굔디?_#

순수 관계 연산::
* 셀렉트, 프로젝트, 조인, 나누기

#일반 집합# 연산::
* #__합__집합, __교__집합, __카__티션 곱, __차__집합#

근원연산(=완전집합)::
* 합집합, 차집합, 카티션곱, 셀렉트, 프로젝트

#복합연산#:: 근원집합의 조합으로 표현 가능
* #__조__인, __교__집합, 나누기(__Di__vision)#


==== 셀렉트(Select) &sigma;
* &sigma;~ID=Razy~(Members)
* &sigma;~Age~ ~>~ ~40~ ~AND~ ~Age~ ~<~ ~50~(Members)

[cols="^1,^1,^1,^1"]
.Relation R
|===
| 학번  | 이름  | _학과_    | 학년

| 100   | 가가  | #컴공#  | 1
| 200   | 나나  | 전산    | 2
| 300   | 다다  | #컴공#  | 1
| 400   | 라라  | 전산    | 3
| 500   | 마마  | 수학    | 4
|===

[cols="^1,^1,^1,^1"]
.&sigma;~학과=컴공~\(R)
|===
| 학번  | 이름  | 학과    | 학년

| 100   | 가가  | 컴공    | 1
| 300   | 다다  | 컴공    | 1
|===

==== 프로젝트(Project) &Pi;
* &Pi;~Name,Age~(Members)
** (집합이므로) 중복된 튜플은 제거된다.

[cols="^1,^1,^1,^1"]
.Relation R
|===
| 학번  | 이름  | _학과_  | _학년_

| 100   | 가가  | 컴공    | 1
| 200   | 나나  | 전산    | 2
| 300   | 다다  | 컴공    | 1
| 400   | 라라  | 전산    | 3
| 500   | 마마  | 수학    | 4
|===

[cols="^1,^1"]
.&Pi;~학과, 학년~\(R) (중복포함)
|===
| 학과  | 학년

| #컴공#  | #1#
| 전산  | 2
| #컴공#  | #1#
| 전산  | 3
| 수학  | 4
|===

[cols="^1,^1"]
.&Pi;~학과, 학년~\(R) (중복제거)
|===
| 학과  | 학년

| 컴공  | 1
| 전산  | 2
| 전산  | 3
| 수학  | 4
|===

==== 합집합() &cup;

==== 교집합() &cap;

==== 차집합() -

==== 카티산 곱() x

==== 조인(Join) ⋈ : #_세동자세_#
세타조인(⋈θ):: 비교연산자가 =, <, >, ... 등
동등조인(⋈):: 세타 조인 중 비교 연산자가 '_=_'
자연조인(⋈):: 동등조인에서 중복 속성이 제거 된것
세미조인(⋉):: 자연조인에서 한쪽 릴레이션의 속성만 나타나는 것
* ⋉ : 왼쪽 속성만 추출
외부조인::
* ⟕ : 열린쪽(왼쪽 Left) 기준
* ⟖ : 열린쪽(오늘쪽 Right) 기준
* ⟗ : 열린쪽(양쪽 Full)

==== 교집합() &cap;

==== 나누기(Division) &div;
* A 중에서 에서 B 를 모두 가지고 있는 Tuple
* A &div; B = 몫 + 나머지
* 결과 릴레이션의 차수는 A차수 - B차수 와 같다

.Relation R
[cols="^1,^1,^1,^1"]
|===
| 학번  | 이름  | 학과    | 학년

| 100   | 가가  | 컴공    | 1
| 200   | 나나  | 전산    | 2
| 300   | 다다  | 컴공    | 1
| 400   | 라라  | 전산    | 3
| 500   | 마마  | 수학    | 4
|===

.Relation S1
[cols="^1"]
|===
| 학과

| 컴공
|===

.Relation R &div; S1
[cols="^1,^1,^1"]
|===
| 학번  | 이름  | 학년

| 100   | 가가  | 1
| 300   | 다다  | 1
|===

=== 2.5.2-2. 일반집합연산: #_합교카차_#
* 합집합:: R1 &cup; R2
* 교집합:: R1 &cap; R2
* 차집합:: R1 - R2
* 카티산 곱 :: R1 x R2

=== 2.5.2-3. 관계대수 연산 완전집합
__근원연산__의 집합 = { &sigma; &pi; &cup; - x }
-> 다른 연산은 근원연산의 조합으로 표현 가능. #셀프합차곱#

=== 2.5.2-4. 추가적인 관계 연산

=== 2.5.3. 관계해석
* 그냥 참조만 할 것
