= 1. 데이터베이스 개요
include::../style/style.adoc[]

== 1.1. 데이터베이스 개념

=== 데이터베이스 정의
한 조직의 여러 응용시스템이 공용(Shared)하기 위해 최소 중복으로 통합(Integrated), 저장(Store)된 운영(Operational) 데이터의 집합

. *``통``합 데이터*(Integrated) : 최소의 중복 / 통제된 중복
. *``저``장 데이터*(Stored) : 컴퓨터가 접근 가능한 매체에 저장
. *``운``영 데이터*(Operational) : 조직 운영에 필요한 필수적인 데이터
. *``공``유 데이터*(Shared) : 여러 응용 프로그램이 공동으로 사용

== 1.2. DBMS 발전 배경
=== 파일시스템의 문제점
. 데이터 종속성(Data Dependency)
* 응용 프로그램과 데이터간의 상호 의존(종속)

. 데이터 중복성(Data Redundancy)
* ``일``관성 :
* ``보``안성 :
* ``경``제성 :
* ``무``결성 :

== 1.3. DBMS 정의
응용프로그램과 데이터의 중재자로서 모든 응용프로그램들이 데이터베이스를 공용할 수 있도록 관리해주는 소프트웨어 시스템

=== 데이터베이스 기능
* **정의**기능(Definition)
* **조작**기능(Manipulation:CRUD)
* **제어**기능(Control)

== 1.4. 데이터베이스 시스템
데이터를 DB로 저장하고 관리해서 필요한 정보를 생성하는 컴퓨터 중심의 시스템

=== 데이터 언어(Data Language)
* 데이터 정의어(DDL)
* 데이터 조작어(DML)
* 데이터 제어어(DCL)

== 1.5. 3단계 데이터베이스 구조
사용자의 응용과 물리적 데이터베이스의 분리

[cols="^2,^1,^2,<5"]
|===
| 단계 | 갯수 | 관점 | 목적
| 외부 Schema | N 개 | 사용자관점  | 사용자 View. 특정 사용자 그룹이 관심을 갖는 부분을 보여주고, 나머지는 은폐
4+| 논리적 Data 독립성 확보
| 개념 Schema | 1 개 | 전사 관점   | 전체 사용자를 위한 데이터베이스의 구조를 기술
4+| 물리적 Data 독립성 확보
| 내부 Schema | 1 개 | 장치 관점   | 물리적 데이터 모델을 사용. 데이터 저장 구조의 세부 사항과 데이터베이스에 대한 접근 경로를 기술
|===

== 1.6. 데이터아키텍쳐 및 데이터베이스 관리
=== 1.6.1. 데이터아키텍쳐 및 데이터베이스 구축 방법론
=== 1.6.2. 공공데이터 품질관리
=== 1.6.3. 공공기관의 데이터베이스 표준화 관리
=== 1.6.4. 데이터 품질 관리 대상 및 품질 지표
==== 데이터 품질 관리 대상
[cols="^4,<6"]
|===
| 관리 대상 ^| 내용
| 데이터 값 <|
* 데이터 현상적 값 +
* 데이터 구조적 값 +
| 데이터 구조 <|
* 각 단계별 데이터 구조 +
* 각 조직 단위별 데이터 구조 +
| 데이터 관리 프로세스 <|
* 데이터 정의 프로세스 +
* 데이터 변경 프로세스 +
* 데이터 평가 프로세스 +
|===

==== 데이터 품질 지표
[cols="^2,^2,<3,<3"]
|===
| 구분 | 지표 ^| 설명 ^| 세부 지표
.2+| 유효성
| 정확성 <| 실세계를 정확히 반영         <| 사실성, 적합성, 필수성, 연관성
| 일관성 <| 동일 데이터간 불일치 미존재  <| 정합성, 일치성, 무결성

.4+| 활용성
| 유용성 <| 요구되는 데이터 춫족         <| 충분성, 유연성, 사용성, 추적성
| 접근성 <| 원하는 데이터를 손쉽게 이용  <| -
| 적시성 <| 최신성 유지                  <| -
| 보안성 <| 내외부 요인으로부터 데이터 보호  <| 보호성, 책임성, 안정성
|===

==== 데이터 품질 관리 프레임워크
==== 데이터 품질 관리 프로세스

== 1.7. 데이터베이스 저장 장치
=== 1.7.1 데이터를 디스크에 물리적으로 저장하는 방법
** 순차 파일(Sequential File)
** 인덱스 파일(Indexed File)
** 해싱 파일(Hashing File)
** B-Tree

=== 1.7.2 자기 디스크 구조
==== 디스크 접근 시간
** 탐색시간
** 회전지연시간
** 전송지연시간

==== Block(Page) 구조
디스크와 주기억장치간 데이터 전송은 Block(Page) 단위로 수행

* `TODO` 이미지 추가

== 1.8. 데이터베이스 접근
==== *Blocking Factor 계산*

== 1.9. 파일조작 기본 방식
* 순차 방법
** 엔트리 순차 파일
** 키 순차 파일
* 인덱스 방법
** 인덱스된 파일
*** ISAM
*** vSAM
** 다중키 파일
*** 다중리스트 파일
*** 역 파일
* 해싱 방법
** 직접 파일
*** Closed Hash
*** Open Hash

=== 1.9.1. 순차 방법
=== 1.9.2. 인덱스 방법
==== 인덱스 분류
* 기본키 여부에 따른 분류
** 기본 인덱스
** 보조 인덱스

* 인덱스 엔트리 순서에 따른 분류
** 집중 인덱스
** 비 집중 인덱스

* 엔트리 맵핑 여부에 따른 분류
** 밀집 인덱스
** 희소 인덱스

* 인덱스를 구성하는 구조나 특징에 따른 분류
** 트리기반 인덱스
** 비트맵 인덱스
** 비트맵조인 인덱스
** 함수기반 인덱스(FBI)

==== 다단계 인덱스
==== 다중키 파일

=== 1.9.3. 해시 방법
==== 용어
* 버켓(Bucket)
* 충돌(Collision)
* 동거자(Synonym)
* 오버플로우(Overflow)

==== 해싱 충돌 해결
Bucket Size 가 고정되었을 경우

* *개방 주소 지정*
* *체인*
* *다중 해싱*

==== 확장성 해시
해싱 충돌 문제점 해결

* `TODO` 좀더 자세히

== 1.10. Tree
=== 1.10.1. Tree 개요
==== 이진 탐색 트리

=== 1.10.2. B Tree
[cols="^2,<4,<4"]
|===
| 구분    ^| B Tree ^| B+ Tree
| 접근성
| * Leaf에 가기전에 값을 찾을 수 있다
| * 레코드의 위치는 Leaf 노드에서만 파악된다 +
* 순차검색(범위검색)이 유리하다
| 중복성
| * 탐색 키의 중복성이 없다
| * Index Set 과 Sequence Set 에 중복된다
| 복잡성
| * Leaf 가 아닌 노드 Size 가 더 크다 +
* Index 에 대한 저장공간 관리가 보잡하다 +
* 삽입, 삭제가 복잡하다
| * 모든 노드의 크기가 같다 +
* 삭제가 쉽다 +
(삭제될 노드가 항상 Leaf 에 존재한다)
|===

* `TODO` image

=== 1.10.3. B-Tree 순회연산
==== B-Tree 전위순회
image::b-tree-전위순회.png[]
* `ROOT` 에서 시작. 왼쪽 빗변을 따라 진행
* 오른쪽 `마지막 노드` **전위순회**로 끝

==== B-Tree 중위순회
image::b-tree-중위순회.png[]
* 왼쪽 `마지막 노드` **중위순회**로 시작
* 오른쪽 `마지막 노드` **중위순회**로 끝

==== B-Tree 후위순회
image::b-tree-후위순회.png[]
* 왼쪽 `마지막 노드` **후위순회**로 시작
* 오른쪽 빗변 **역순**으로 끝

=== 1.10.4. B-Tree 삽입 연산

* `TODO`
