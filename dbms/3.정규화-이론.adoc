= 3. 정규화 이론
include::../_toc.adoc[]

== 3.0. 개요
* 개념적 설계 단계와 논리적 설계 단계 사이에서 수행
* 개체에 존재하는 함수적 종속 관계를 이용하여 데이터베이스 구조를 안정화 시킨다.

== 3.1. 데이터 종속 문제
=== 이상(Anomaly)
삽입이상(Insertion Anomaly)::
* 원하지 않은 값들도 함께 삽입되는 현상
* 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
갱신이상(Update Anomaly)::
* 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상
* 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
삭제이상(Deletion Anomaly)::
* 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상
* 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제

== 3.2. 함수적 종속성
(FD: Functional Dependency)

Relation R의 애트리뷰트들의 집합 X의 값이 애트리뷰트들의 집합 Y의 값을 유일하게(Unique) 결정한다면 +
'집합 X 는 집합 Y 를 함수적으로 결정' 한다고 한다.

https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency

* X -> Y
** X : 결정자(Determinant)
** Y : 종속자(Dependent)

R = { 학번, 과목, 성적, 학년 }

=== 완전 함수 종속
X = { *학번*, *과목* }, Y = { *성적* } 일 때, Y 는 X 에 대해 *완전 함수 종속*

* 학번과 과목 을 모두 알아야 성적을 알 수 있다.

=== 부분 함수 종속
X = { _학번_, *과목* }, S = { *학년* } 일 때, S 는 X 에 대해 *부분 함수 종속*

* 학번과 과목 중 학번 만으로 학년을 알 수 있다.

=== 이행적 함수 종속
X -> Y 이고 Y -> Z 이며, X -> Z 가 성립할 때

== 3.3. 추론 규칙
=== 3.3.1. 암스트롱의 추론 규칙
* _재귀_ 규칙 : *Y &sube; X* 이면, *X -> Y* 이다
* _부가_ 규칙 : *X -> Y* 이면, *XZ -> YZ* 이다 (XZ = X &cup; Z)
* _이행_ 규칙 : *X -> Y* 이고 *Y -> Z* 이면, *X -> Z* 이다

* 분해 규칙 : *X -> YZ* 이면, *X -> Y* 이고, *X -> Z* 이다
* 합집합 규칙 : *X -> Y* 이고, *X -> Z* 이면, *X -> YZ* 이다 (분해 규칙의 역)
* 의사이행 규칙 : *X -> Y* 이고, *WY -> Z* 이면, *WX -> Z* 이다

=== 3.3.2. 페포(Closure) 이론
X 에 종속되었다고 추론할 수 있는 모든 집합

* X -> YZ 일 때, X+ = X, Y, Z
** X: 자기 자신
** X -> Y and X -> Z 성립

==== eg>
R = { A, B, C, D, E }

* { A } -> { C }
* { B } -> { D }
* { A, B } -> { E }

일 때,

* A+ = { A, C }
** A 자신, A -> C

* B+ = { B, D }
** B 자신, B -> D

* { A, B }+ = { #A, C#, #B, D#, #E# }
** A 자신
** A -> C 에 의해 C
** B 자신
** B -> D 에 의해 D
** AB -> E 에 의해 E

-> { A, B }+ 가 R 의 모든 속성(Attribute)를 가지므로, R 의 Key 는 { A, B } 가 됨

=== 3.3.3. Cover
* G+ &sube; F+ 이면, F 가 G 를 덮는다(Cover)
* G+ = F+ 이면, G 와 F 는 동등하다.

=== 3.3.4. 함수적 종속성들의 집합 F의 최소(Minimal)
* 조건 1. F 의 모든 종속성의 오른쪽 속성(Attribute)이 1개이다 (오른쪽 한개로)
* 조건 2. 대체 가능한 함수적 종속성이 없다 (왼쪽을 1개로)
* 조건 3. 제거 가능한 함수적 종속성이 없다 (중복 제거)

=== 3.3.5. Minimal Cover
E = { B -> A, D -> A, AB -> D} 일때

조건 1. ::
* 모든 종속성의 오른쪽 속성이 1개 이다. OK

조건 2. ::
* AB -> D 를 A -> D 또는 B -> D 로 대치 가능 한가?
* B -> A = BB -> AB = B -> AB (부가규칙)
* B -> AB 이고, AB -> D 이므로 B -> D (이행규칙)
* E = { B -> A, D -> A, [.line-through]#AB -> D# #B -> D# }

조건 3. ::
* B -> D 이고, D -> A 이므로 *B -> A* (이행규칙)
* E = { [.line-through]#B -> A#, D -> A, B -> D }

== 3.4. 정규화
무손실 분해(Lossless Decomposition):: 저장 정보 손실이 없어야 함
종속 보전 분해:: 함수적 종속성 유지 되어야 함

//--

=== 3.4.1. 제1 정규형(1NF)

.Relation R
[cols="^1,^1,^1,^1,^1,^1,^1"]
|===
| [.underline]#학번#  | 이름 | [.underline]#과목# | 교수 | 학점 | 학과 | 학비

| 100   | 가가 | _수학, 물리_ | _나수학, 나물리_ | _A, C_ | 전산 | 1000
| 200   | 나나 | 물리 | 나물리 | A | 기계 | 1200
| 200   | 나나 | 화학 | 나화학 | B | 기계 | 1200
| 300   | 다다 | 화학 | 나화학 | D | 컴공 | 1400
| 400   | 라라 | 코딩 | 나코딩 | C | 컴공 | 1400
| 500   | 마마 | 자바 | 나자바 | F | 컴공 | 1400
|===

==== 제1 정규형(1NF)
* R 의 모든 도메인이 원자값(Atomic Value)으로 되 있을 때
* 복합, 다치, 중첩 릴레이션 등 비원자적(Non-Atomic) 속성(Attribute)을 허용 하지 않음

==== 제1 정규화 결과
.Relation R
[cols="^1,^1,^1,^1,^1,^1,^1"]
|===
| [.underline]#학번#  | 이름 | [.underline]#과목# | 교수 | 학점 | 학과 | 학비

| 100   | 가가 | 수학 | 나수학 | A | 전산 | 1000
| 100   | 가가 | 물리 | 나물리 | C | 전산 | 1000
| 200   | 나나 | 물리 | 나물리 | A | 기계 | 1200
| 200   | 나나 | 화학 | 나화학 | B | 기계 | 1200
| 300   | 다다 | 화학 | 나화학 | D | 컴공 | 1400
| 400   | 라라 | 코딩 | 나코딩 | C | 컴공 | 1400
| 500   | 마마 | 자바 | 나자바 | F | 컴공 | 1400
|===

* 부분 함수종속 이 존재함
** {학번, 과목} -> 이름
** {학번, 과목} -> 교수
** {학번, 과목} -> 학점
** {학번, 과목} -> 학과
** {학번, 과목} -> 학비

*** 학번 -> 이름
*** 학번 -> 학과
*** 학번 -> 학비

==== 제1 정규형(1NF) 문제점
* 삽입이상
* 갱신이상
* 삭제이상

=== 3.4.2. 제2 정규형(2NF)
==== 제2 정규형(2NF)
* 부분함수종속 제거
* R 이 제1 정규형 이고, 모든 속성(Attribute) 가 ##기본키##에 #완전함수종속# 일 때

==== 제2 정규화 결과

.Relation R1
[cols="^1,^1,^1,^1"]
|===
| [.underline]#학번#  | [.underline]#과목# | 교수 | 학점

| 100   | 수학 | 나수학 | A
| 100   | 물리 | 나물리 | C
| 200   | 물리 | 나물리 | A
| 200   | 화학 | 나화학 | B
| 300   | 화학 | 나화학 | D
| 400   | 코딩 | 나코딩 | C
| 500   | 자바 | 나자바 | F
|===

.Relation R2
[cols="^1,^1,^1,^1"]
|===
| [.underline]#학번#  | 이름 | 학과 | 학비

| 100   | 가가 | 전산 | 1000
| 200   | 나나 | 기계 | 1200
| 300   | 다다 | 컴공 | 1400
| 400   | 라라 | 컴공 | 1400
| 500   | 마마 | 컴공 | 1400
|===

* 이행적 함수종속
** 학번 -> 학과 and 학과 -> 학비

==== 제2 정규형(2NF) 문제점
* 삽입이상
* 갱신이상
* 삭제이상

=== 3.4.3. 제3 정규형(3NF)
==== 제3 정규형(3NF)
* 이행적 함수종속 제거

==== 제3 정규화 결과
.Relation R2-1
[cols="^1,^1,^1"]
|===
| [.underline]#학번#  | 이름 | 학과

| 100   | 가가 | 전산
| 200   | 나나 | 기계
| 300   | 다다 | 컴공
| 400   | 라라 | 컴공
| 500   | 마마 | 컴공
|===

.Relation R2-1
[cols="^1,^1"]
|===
| 학과 | 학비

| 전산 | 1000
| 기계 | 1200
| 컴공 | 1400
|===

==== 제3 정규형(3NF) 문제점

=== 3.4.4. BCNF
==== BCNF

==== BCNF 결과

==== BCNF 문제점


=== 3.4.5. 제4 정규형(4NF)
=== 3.4.6. 제5 정규형(5NF)
=== 3.4.7 정규화 단계
=== 3.4.8. 반정규화(De-Normalization)
=== 3.4.9. 연결함정(Connection Trap)
=== 3.4.10. 부채꼴함정(Fan Trap)